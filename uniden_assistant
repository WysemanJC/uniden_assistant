#!/bin/bash
# Uniden Assistant - Application Orchestration Script
# Comprehensive start/stop/restart/status management
# DO NOT PIPE THIS SCRIPT THROUGH TAIL OR OTHER COMMANDS
# Usage: ./uniden_assistant {start|stop|restart|status|logs|help}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BACKEND_PORT=8001
FRONTEND_PORT=9001
PID_DIR="$SCRIPT_DIR/.pids"
BACKEND_PID_FILE="$PID_DIR/backend.pid"
FRONTEND_PID_FILE="$PID_DIR/frontend.pid"
LOG_DIR="$SCRIPT_DIR/.logs"
BACKEND_LOG="$LOG_DIR/backend.log"
FRONTEND_LOG="$LOG_DIR/frontend.log"

# Function to print colored output
print_status() {
    echo -e "${BLUE}[*]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[✓]${NC} $1"
}

print_error() {
    echo -e "${RED}[✗]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

print_info() {
    echo -e "${CYAN}[i]${NC} $1"
}

# Function to load config.env into environment
load_env_file() {
    local env_file="$SCRIPT_DIR/config.env"
    if [ -f "$env_file" ]; then
        set -a
        # shellcheck disable=SC1090
        . "$env_file"
        set +a
    fi
}

# Function to determine FQDN and set backend URL
set_backend_url() {
    # Load config to get BACKEND_URL
    load_env_file
    
    # Get FQDN for use in configuration
    local fqdn=$(hostname -f 2>/dev/null || hostname)
    export FQDN="$fqdn"
    
    # If BACKEND_URL is not set or empty, auto-detect
    if [ -z "${BACKEND_URL:-}" ]; then
        BACKEND_URL="http://${fqdn}:${BACKEND_PORT}"
        print_info "Auto-detected backend URL: $BACKEND_URL"
    else
        print_info "Using configured backend URL: $BACKEND_URL"
    fi
    
    # Export for use by backend and frontend
    export BACKEND_URL
    
    # Set frontend URL for CORS
    FRONTEND_URL="http://${fqdn}:${FRONTEND_PORT}"
    export FRONTEND_URL
    
    # Update CORS_ALLOWED_ORIGINS to include detected URLs
    if [ -n "${CORS_ALLOWED_ORIGINS:-}" ]; then
        export CORS_ALLOWED_ORIGINS="${CORS_ALLOWED_ORIGINS},${FRONTEND_URL}"
    else
        export CORS_ALLOWED_ORIGINS="http://localhost:9001,http://localhost:3000,http://localhost:8080,http://127.0.0.1:9001,http://127.0.0.1:3000,${FRONTEND_URL}"
    fi
    
    # Update ALLOWED_HOSTS to include detected hostname
    if [ -n "${ALLOWED_HOSTS:-}" ]; then
        export ALLOWED_HOSTS="${ALLOWED_HOSTS},${fqdn}"
    else
        export ALLOWED_HOSTS="localhost,127.0.0.1,${fqdn}"
    fi
}

# Function to check if port is in use
is_port_in_use() {
    local port=$1
    if command -v lsof >/dev/null 2>&1; then
        lsof -i ":$port" >/dev/null 2>&1
        return $?
    elif command -v ss >/dev/null 2>&1; then
        ss -tlnp 2>/dev/null | grep ":$port " >/dev/null 2>&1
        return $?
    elif command -v netstat >/dev/null 2>&1; then
        netstat -tlnp 2>/dev/null | grep ":$port " >/dev/null 2>&1
        return $?
    fi
    return 1
}

# Function to get process using port
get_port_process() {
    local port=$1
    if command -v lsof >/dev/null 2>&1; then
        lsof -i ":$port" 2>/dev/null | awk 'NR>1 {print $2}' | head -1
    elif command -v ss >/dev/null 2>&1; then
        ss -tlnp 2>/dev/null | grep ":$port " | grep -oP 'pid=\K[0-9]+' | head -1
    elif command -v netstat >/dev/null 2>&1; then
        netstat -tlnp 2>/dev/null | grep ":$port " | awk '{print $NF}' | cut -d'/' -f1 | head -1
    fi
}

# Function to kill process on port
kill_port_process() {
    local port=$1
    local name=$2
    local pid=$(get_port_process "$port")
    
    if [ -n "$pid" ] && [ "$pid" != "-" ]; then
        print_warning "Found process $pid using port $port ($name)"
        print_status "Killing process $pid..."
        kill -15 "$pid" 2>/dev/null || true
        sleep 2
        
        # Force kill if still running
        if kill -0 "$pid" 2>/dev/null; then
            print_status "Force killing process $pid..."
            kill -9 "$pid" 2>/dev/null || true
            sleep 1
        fi
        
        print_success "Process $pid killed"
    fi
}

# Function to create necessary directories
setup_directories() {
    mkdir -p "$PID_DIR" "$LOG_DIR"
}

# Function to validate setup
validate_setup() {
    local errors=0
    
    if [ ! -d "$SCRIPT_DIR/backend" ] || [ ! -d "$SCRIPT_DIR/frontend" ]; then
        print_error "Project structure not found. Please ensure you're in the correct directory."
        ((errors++))
    fi
    
    if [ ! -d "$SCRIPT_DIR/backend/venv" ]; then
        print_error "Backend virtual environment not found."
        print_info "Run: ./setup_uniden.sh"
        ((errors++))
    fi
    
    if [ ! -d "$SCRIPT_DIR/frontend/node_modules" ]; then
        print_error "Frontend dependencies not found."
        print_info "Run: ./setup_uniden.sh"
        ((errors++))
    fi
    
    if [ "$errors" -gt 0 ]; then
        exit 1
    fi
}

# Function to check and prepare databases
prepare_databases() {
    print_status "Preparing databases..."
    
    cd "$SCRIPT_DIR/backend"
    load_env_file
    
    # Export all MongoDB URIs and credentials to environment
    export DJANGO_SETTINGS_MODULE=uniden_assistant.settings
    export UNIDEN_HPDB_DB
    export UNIDEN_USERSETTINGS_DB
    export UNIDEN_APP_DB
    export UNIDEN_HPDB_DB_USER
    export UNIDEN_HPDB_DB_PASSWORD
    export UNIDEN_USERSETTINGS_DB_USER
    export UNIDEN_USERSETTINGS_DB_PASSWORD
    export UNIDEN_APP_DB_USER
    export UNIDEN_APP_DB_PASSWORD
    
    if [ ! -f "$SCRIPT_DIR/backend/venv/bin/activate" ]; then
        print_error "Backend virtual environment not found."
        print_info "Run: ./setup_uniden.sh"
        return 1
    fi
    source venv/bin/activate
    if [ "${VIRTUAL_ENV:-}" != "$SCRIPT_DIR/backend/venv" ]; then
        print_warning "Venv path mismatch detected; correcting environment"
        VIRTUAL_ENV="$SCRIPT_DIR/backend/venv"
        export VIRTUAL_ENV
        PATH="$VIRTUAL_ENV/bin:$PATH"
        export PATH
        hash -r 2>/dev/null || true
    fi
    if ! command -v python >/dev/null 2>&1; then
        print_error "python not found after activating venv"
        deactivate
        return 1
    fi
    
    # Note: Migrations are not run here. Run them manually with:
    # cd backend && python run_with_config.py migrate
    # or during initial setup with: ./setup_uniden.sh
    
    deactivate
    print_success "Database preparation complete"
}

# Function to start backend
start_backend() {
    print_status "Starting backend (Django)..."
    
    # Set backend URL before starting
    set_backend_url
    
    # Check if port is in use by another process
    if is_port_in_use $BACKEND_PORT; then
        kill_port_process $BACKEND_PORT "backend"
        sleep 2
    fi
    
    # Check if already running via PID file
    if [ -f "$BACKEND_PID_FILE" ]; then
        local old_pid=$(cat "$BACKEND_PID_FILE")
        if kill -0 "$old_pid" 2>/dev/null; then
            print_warning "Backend already running (PID: $old_pid)"
            return 0
        else
            rm "$BACKEND_PID_FILE"
        fi
    fi
    
    # Prepare databases before starting
    prepare_databases
    
    # Start backend
    cd "$SCRIPT_DIR/backend"
    load_env_file
    
    # Export all MongoDB URIs and credentials to environment
    export DJANGO_SETTINGS_MODULE=uniden_assistant.settings
    export UNIDEN_HPDB_DB
    export UNIDEN_USERSETTINGS_DB
    export UNIDEN_APP_DB
    export UNIDEN_HPDB_DB_USER
    export UNIDEN_HPDB_DB_PASSWORD
    export UNIDEN_USERSETTINGS_DB_USER
    export UNIDEN_USERSETTINGS_DB_PASSWORD
    export UNIDEN_APP_DB_USER
    export UNIDEN_APP_DB_PASSWORD
    export ALLOWED_HOSTS
    export CORS_ALLOWED_ORIGINS
    
    if [ ! -f "$SCRIPT_DIR/backend/venv/bin/activate" ]; then
        print_error "Backend virtual environment not found."
        print_info "Run: ./setup_uniden.sh"
        return 1
    fi
    source venv/bin/activate
    if [ "${VIRTUAL_ENV:-}" != "$SCRIPT_DIR/backend/venv" ]; then
        print_warning "Venv path mismatch detected; correcting environment"
        VIRTUAL_ENV="$SCRIPT_DIR/backend/venv"
        export VIRTUAL_ENV
        PATH="$VIRTUAL_ENV/bin:$PATH"
        export PATH
        hash -r 2>/dev/null || true
    fi
    if ! command -v python >/dev/null 2>&1; then
        print_error "python not found after activating venv"
        deactivate
        return 1
    fi
    
    # Clear old log
    > "$BACKEND_LOG"
    
    # Start using virtual environment's Python with wrapper that loads config.env
    nohup python run_with_config.py runserver 0.0.0.0:$BACKEND_PORT >> "$BACKEND_LOG" 2>&1 &
    local pid=$!
    echo $pid > "$BACKEND_PID_FILE"
    deactivate
    
    # Wait and verify server started
    sleep 3
    
    if kill -0 "$pid" 2>/dev/null; then
        if is_port_in_use $BACKEND_PORT; then
            print_success "Backend started (PID: $pid)"
            print_info "  URL: http://localhost:$BACKEND_PORT"
            print_info "  Log: $BACKEND_LOG"
            return 0
        else
            print_error "Backend process running but port not listening"
            cat "$BACKEND_LOG"
            return 1
        fi
    else
        print_error "Backend failed to start"
        print_error "Last 20 lines of log:"
        cat "$BACKEND_LOG"
        return 1
    fi
}

# Function to start frontend
start_frontend() {
    print_status "Starting frontend (Vue/Quasar)..."
    
    # Ensure backend URL is set
    if [ -z "${BACKEND_URL:-}" ]; then
        set_backend_url
    fi
    
    # Check if port is in use by another process
    if is_port_in_use $FRONTEND_PORT; then
        kill_port_process $FRONTEND_PORT "frontend"
        sleep 2
    fi
    
    # Check if already running via PID file
    if [ -f "$FRONTEND_PID_FILE" ]; then
        local old_pid=$(cat "$FRONTEND_PID_FILE")
        if kill -0 "$old_pid" 2>/dev/null; then
            print_warning "Frontend already running (PID: $old_pid)"
            return 0
        else
            rm "$FRONTEND_PID_FILE"
        fi
    fi
    
    # Start frontend
    cd "$SCRIPT_DIR/frontend"
    
    # Create/update .env.local with backend URL
    cat > .env.local <<EOF
VITE_API_URL=${BACKEND_URL}/api
EOF
    
    # Clear old log
    > "$FRONTEND_LOG"
    
    # Export variables for vite.config.js
    export BACKEND_URL
    export FQDN
    
    nohup npm run dev >> "$FRONTEND_LOG" 2>&1 &
    local pid=$!
    echo $pid > "$FRONTEND_PID_FILE"
    
    # Wait and verify server started
    sleep 4
    
    if kill -0 "$pid" 2>/dev/null; then
        if is_port_in_use $FRONTEND_PORT; then
            print_success "Frontend started (PID: $pid)"
            print_info "  URL: http://localhost:$FRONTEND_PORT"
            print_info "  Log: $FRONTEND_LOG"
            return 0
        else
            print_warning "Frontend process running but port not listening yet"
            print_info "  It may still be starting up..."
            print_info "  Log: $FRONTEND_LOG"
            return 0
        fi
    else
        print_error "Frontend failed to start"
        print_error "Last 20 lines of log:"
        tail -20 "$FRONTEND_LOG"
        return 1
    fi
}

# Function to stop backend
stop_backend() {
    print_status "Stopping backend..."
    
    local stopped=0
    
    # Stop via PID file
    if [ -f "$BACKEND_PID_FILE" ]; then
        local pid=$(cat "$BACKEND_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            kill -15 "$pid" 2>/dev/null || true
            sleep 2
            
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
                sleep 1
            fi
            
            stopped=1
        fi
        rm "$BACKEND_PID_FILE"
    fi
    
    # Kill any process on backend port
    if is_port_in_use $BACKEND_PORT; then
        kill_port_process $BACKEND_PORT "backend"
        stopped=1
    fi
    
    if [ "$stopped" -eq 1 ]; then
        print_success "Backend stopped"
    else
        print_info "Backend was not running"
    fi
}

# Function to stop frontend
stop_frontend() {
    print_status "Stopping frontend..."
    
    local stopped=0
    
    # Stop via PID file
    if [ -f "$FRONTEND_PID_FILE" ]; then
        local pid=$(cat "$FRONTEND_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            kill -15 "$pid" 2>/dev/null || true
            sleep 2
            
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
                sleep 1
            fi
            
            stopped=1
        fi
        rm "$FRONTEND_PID_FILE"
    fi
    
    # Kill any process on frontend port
    if is_port_in_use $FRONTEND_PORT; then
        kill_port_process $FRONTEND_PORT "frontend"
        stopped=1
    fi
    
    if [ "$stopped" -eq 1 ]; then
        print_success "Frontend stopped"
    else
        print_info "Frontend was not running"
    fi
}

# Function to get status
show_status() {
    echo ""
    echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║              Uniden Assistant Status                       ║${NC}"
    echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # Backend status
    echo -e "${CYAN}Backend (Port $BACKEND_PORT):${NC}"
    if [ -f "$BACKEND_PID_FILE" ]; then
        local pid=$(cat "$BACKEND_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            if is_port_in_use $BACKEND_PORT; then
                print_success "Running (PID: $pid)"
                print_info "  URL: http://localhost:$BACKEND_PORT"
            else
                print_warning "Process running but port not listening (PID: $pid)"
            fi
        else
            print_error "Not running (stale PID file)"
        fi
    else
        if is_port_in_use $BACKEND_PORT; then
            local pid=$(get_port_process $BACKEND_PORT)
            print_warning "Running without PID file (PID: $pid)"
        else
            print_error "Not running"
        fi
    fi
    echo ""
    
    # Frontend status
    echo -e "${CYAN}Frontend (Port $FRONTEND_PORT):${NC}"
    if [ -f "$FRONTEND_PID_FILE" ]; then
        local pid=$(cat "$FRONTEND_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            if is_port_in_use $FRONTEND_PORT; then
                print_success "Running (PID: $pid)"
                print_info "  URL: http://localhost:$FRONTEND_PORT"
            else
                print_warning "Process running but port not listening (PID: $pid)"
            fi
        else
            print_error "Not running (stale PID file)"
        fi
    else
        if is_port_in_use $FRONTEND_PORT; then
            local pid=$(get_port_process $FRONTEND_PORT)
            print_warning "Running without PID file (PID: $pid)"
        else
            print_error "Not running"
        fi
    fi
    echo ""
}

# Function to show logs
show_logs() {
    local service=$1
    
    case "$service" in
        backend|be|b)
            echo -e "${CYAN}=== Backend Log (last 50 lines) ===${NC}"
            if [ -f "$BACKEND_LOG" ]; then
                cat "$BACKEND_LOG"
            else
                print_error "Backend log not found"
            fi
            ;;
        frontend|fe|f)
            echo -e "${CYAN}=== Frontend Log (last 50 lines) ===${NC}"
            if [ -f "$FRONTEND_LOG" ]; then
                cat "$FRONTEND_LOG"
            else
                print_error "Frontend log not found"
            fi
            ;;
        both|all|"")
            echo -e "${CYAN}=== Backend Log (last 30 lines) ===${NC}"
            if [ -f "$BACKEND_LOG" ]; then
                cat "$BACKEND_LOG"
            else
                print_error "Backend log not found"
            fi
            echo ""
            echo -e "${CYAN}=== Frontend Log (last 30 lines) ===${NC}"
            if [ -f "$FRONTEND_LOG" ]; then
                cat "$FRONTEND_LOG"
            else
                print_error "Frontend log not found"
            fi
            ;;
        *)
            print_error "Unknown service: $service"
            print_info "Use: backend, frontend, or both"
            exit 1
            ;;
    esac
}

# Function to follow logs
follow_logs() {
    local service=$1
    
    case "$service" in
        backend|be|b)
            if [ -f "$BACKEND_LOG" ]; then
                while true; do
                    clear
                    cat "$BACKEND_LOG"
                    sleep 2
                done
            else
                print_error "Backend log not found"
            fi
            ;;
        frontend|fe|f)
            if [ -f "$FRONTEND_LOG" ]; then
                while true; do
                    clear
                    cat "$FRONTEND_LOG"
                    sleep 2
                done
            else
                print_error "Frontend log not found"
            fi
            ;;
        *)
            print_error "Please specify: backend or frontend"
            exit 1
            ;;
    esac
}

# Function to run database migrations
run_migrations() {
    print_status "Running database migrations..."
    
    cd "$SCRIPT_DIR/backend"
    load_env_file
    
    # Export all MongoDB URIs
    export DJANGO_SETTINGS_MODULE=uniden_assistant.settings
    export UNIDEN_HPDB_DB
    export UNIDEN_USERSETTINGS_DB
    export UNIDEN_APP_DB
    export UNIDEN_HPDB_DB_USER
    export UNIDEN_HPDB_DB_PASSWORD
    export UNIDEN_USERSETTINGS_DB_USER
    export UNIDEN_USERSETTINGS_DB_PASSWORD
    export UNIDEN_APP_DB_USER
    export UNIDEN_APP_DB_PASSWORD
    
    if [ ! -f "$SCRIPT_DIR/backend/venv/bin/activate" ]; then
        print_error "Backend virtual environment not found."
        print_info "Run: ./setup_uniden.sh"
        return 1
    fi
    
    source venv/bin/activate
    if [ "${VIRTUAL_ENV:-}" != "$SCRIPT_DIR/backend/venv" ]; then
        VIRTUAL_ENV="$SCRIPT_DIR/backend/venv"
        export VIRTUAL_ENV
        PATH="$VIRTUAL_ENV/bin:$PATH"
        export PATH
        hash -r 2>/dev/null || true
    fi
    
    if ! command -v python >/dev/null 2>&1; then
        print_error "python not found after activating venv"
        deactivate
        return 1
    fi
    
    # Apply migrations (SQLite default only)
    print_status "Applying migrations (default database)..."
    python run_with_config.py migrate --noinput --database=default
    if [ $? -eq 0 ]; then
        print_success "Migrations completed successfully"
    else
        print_error "Migrations failed"
        deactivate
        return 1
    fi
    
    deactivate
}

# Function to show help
show_help() {
    cat << EOF

${CYAN}Uniden Assistant - Application Orchestration Script${NC}

${YELLOW}USAGE:${NC}
    ./uniden_assistant <command> [options]

${YELLOW}COMMANDS:${NC}
    ${GREEN}start${NC}               Start both backend and frontend
    ${GREEN}stop${NC}                Stop both backend and frontend
    ${GREEN}restart${NC}             Stop and start both services
    ${GREEN}status${NC}              Show status of all services
    ${GREEN}logs${NC} [service]      Show logs (backend|frontend|both)
    ${GREEN}follow${NC} <service>    Follow logs in real-time (backend|frontend)
    ${GREEN}migrate${NC}             Run default (SQLite) migrations
    ${GREEN}help${NC}                Show this help message

${YELLOW}EXAMPLES:${NC}
    ./uniden_assistant start
    ./uniden_assistant stop
    ./uniden_assistant restart
    ./uniden_assistant status
    ./uniden_assistant logs backend
    ./uniden_assistant logs both
    ./uniden_assistant follow backend
    ./uniden_assistant migrate

${YELLOW}IMPORTANT:${NC}
    - Run ./setup_uniden.sh first to set up the environment
    - DO NOT pipe this script through tail or other commands
    - Logs are stored in: $LOG_DIR/
    - PIDs are stored in: $PID_DIR/
    - Migrations are run manually with: ./uniden_assistant migrate

${YELLOW}TROUBLESHOOTING:${NC}
    If services fail to start:
    1. Check logs: ./uniden_assistant logs
    2. Verify setup: ./setup_uniden.sh
    3. Check ports: Make sure ports $BACKEND_PORT and $FRONTEND_PORT are available
    4. Run migrations: ./uniden_assistant migrate
EOF
    4. Check databases: Ensure MongoDB is running if required

EOF
}

# Main command handler
main() {
    # Setup directories
    setup_directories
    
    # Get command
    local command=${1:-help}
    shift || true
    
    case "$command" in
        start)
            echo ""
            echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${BLUE}║              Starting Uniden Assistant                     ║${NC}"
            echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
            echo ""
            
            validate_setup
            
            if start_backend && start_frontend; then
                echo ""
                echo -e "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}"
                echo -e "${GREEN}║          Application Started Successfully! ✓               ║${NC}"
                echo -e "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}"
                echo ""
                print_info "Frontend: http://localhost:$FRONTEND_PORT"
                print_info "Backend:  http://localhost:$BACKEND_PORT/api"
                print_info "Admin:    http://localhost:$BACKEND_PORT/admin"
                echo ""
                print_info "To view logs: ./uniden_assistant logs"
                print_info "To stop:      ./uniden_assistant stop"
                echo ""
            else
                echo ""
                print_error "Application failed to start completely"
                print_info "Check logs with: ./uniden_assistant logs"
                echo ""
                exit 1
            fi
            ;;
        
        stop)
            echo ""
            echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${BLUE}║              Stopping Uniden Assistant                     ║${NC}"
            echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
            echo ""
            
            stop_backend
            stop_frontend
            
            echo ""
            print_success "Application stopped"
            echo ""
            ;;
        
        restart)
            echo ""
            echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${BLUE}║             Restarting Uniden Assistant                    ║${NC}"
            echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
            echo ""
            
            validate_setup
            
            stop_backend
            stop_frontend
            
            sleep 2
            
            if start_backend && start_frontend; then
                echo ""
                echo -e "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}"
                echo -e "${GREEN}║         Application Restarted Successfully! ✓              ║${NC}"
                echo -e "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}"
                echo ""
            else
                echo ""
                print_error "Application failed to restart"
                echo ""
                exit 1
            fi
            ;;
        
        status)
            show_status
            ;;
        
        logs)
            local service=${1:-both}
            show_logs "$service"
            ;;
        
        follow)
            local service=$1
            if [ -z "$service" ]; then
                print_error "Please specify service: backend or frontend"
                print_info "Example: ./uniden_assistant follow backend"
                exit 1
            fi
            follow_logs "$service"
            ;;
        
        migrate)
            echo ""
            echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${BLUE}║           Running Database Migrations                      ║${NC}"
            echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
            echo ""
            run_migrations
            echo ""
            ;;
        
        help|--help|-h)
            show_help
            ;;
        
        *)
            print_error "Unknown command: $command"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
